	assume	adl=1

	section	.text
	public	_modff
	public	_modf

if PREFER_OS_LIBC

_modff := 0220ECh
_modf := _modff

else

; float modf(float x, float* iptr)
; Warning: It is assumed that _truncf preserves IY
_modff:
_modf:
	ld	iy, 0
	add	iy, sp

	; copy the mantissa into HL and BC
	sbc	hl, hl
	ld	bc, (iy + 3)	; mantissa
	add	hl, bc		; ld hl, bc
	adc	hl, hl
	ld	a, (iy + 6)	; exponent
	ld	e, a
	rla
	jr	z, .maybe_inf	; performs inc a
	inc	a
	jr	z, .nan_value
.not_inf:
	; cp	a, 127 + 1	; |x| < 1.0f
	rla	; allows us to test cp a, 128
	jr	nc, .less_than_one
	; finite and normal

	; push	iy	; preserve IY in case we link to a different _truncf
	push	de	; E has exponent
	push	bc	; mantissa
	call	_truncf
	pop	af, af
	; pop	iy

	; load the original argument
	ld	bc, (iy + 3)
	ld	a, (iy + 6)
	ld	iy, (iy + 9)	; float *iptr
	; store the truncated value
	ld	(iy + 0), hl
	ld	(iy + 3), e

	; A:UBC - E:UHL, the result will be exact
	call	__fsub
	; __fsub does not currently emit negative zero
	push	bc
	pop	hl
	ld	e, a
	ret

.maybe_inf:
	; HL is zero
	inc	a
	jr	nz, .not_inf
	; Signbit = Carry
	; return +-inf and store +-0
	ld	a, e
	ld	e, b	; ld e, 0
	rr	e	; shift the carry back in
	jr	.ret_inf

.nan_value:
	; return +-NaN and store +-NaN
	ld	a, e
	jr	.ret_nan

.less_than_one:
	; return X and store +-0
	; Signbit = bit 0 of A
	ld	bc, 0
	ld	a, e
	and	a, $80
.ret_nan:
	ld	hl, (iy + 3)	; mantissa
.ret_inf:
	ld	iy, (iy + 9)	; float *iptr
	ld	(iy + 0), bc
	ld	(iy + 3), a
	; E has exponent
	ret

	extern	_truncf
	extern	__fsub

end if
