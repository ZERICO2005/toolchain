// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _EZCXX_ALGORITHM
#define _EZCXX_ALGORITHM

#include <__config>

// currently unused, but included in the standard
#include <initializer_list>

#include <iterator>
#include <tuple>
#include <utility>

#include <EASTL/algorithm.h>
#include <EASTL/heap.h>
#include <EASTL/sort.h>

#pragma clang system_header

// very limited implementation of <algorithm>
// only supports std:max, std::min, and std::clamp
// these functions can be replaced when <algorithm> is properly implemented

namespace std {

template <class _Tp, class _Compare> _EZCXX_NODISCARD_EXT inline constexpr
const _Tp& max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp> _EZCXX_NODISCARD_EXT inline constexpr
const _Tp& max(const _Tp& __a, const _Tp& __b)
{
    return (__a < __b) ? __b : __a;
}

template <class _Tp, class _Compare> _EZCXX_NODISCARD_EXT inline constexpr
const _Tp& min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __a : __b;
}

template <class _Tp> _EZCXX_NODISCARD_EXT inline constexpr
const _Tp& min(const _Tp& __a, const _Tp& __b)
{
    return (__a < __b) ? __a : __b;
}

template <class _Tp, class _Compare> _EZCXX_NODISCARD_EXT inline constexpr
const _Tp& clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
{
    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;
}

template <class _Tp> _EZCXX_NODISCARD_EXT inline constexpr
const _Tp& clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)
{
    return (__v < __lo) ? __lo : (__hi < __v) ? __hi : __v;
}

template<typename _ForwardIt, typename _Tp>
void fill(_ForwardIt first, _ForwardIt last, const _Tp& value) {
    eastl::fill(first, last, value);
}

template<typename _OutputIt, typename _Size, typename _Tp>
_OutputIt fill_n(_OutputIt first, _Size count, const _Tp& value) {
    return eastl::fill_n(first, count, value);
}

template<class _RandomIt >
void make_heap(_RandomIt first, _RandomIt last) {
    return eastl::make_heap(first, last);
}

template<class _RandomIt, class _Compare>
void make_heap(_RandomIt first, _RandomIt last, _Compare comp) {
    return eastl::make_heap(first, last, comp);
}

template<class _RandomIt >
void push_heap(_RandomIt first, _RandomIt last) {
    return eastl::push_heap(first, last);
}

template<class _RandomIt, class _Compare>
void push_heap(_RandomIt first, _RandomIt last, _Compare comp) {
    return eastl::push_heap(first, last, comp);
}

template<class _RandomIt >
void pop_heap(_RandomIt first, _RandomIt last) {
    return eastl::pop_heap(first, last);
}

template<class _RandomIt, class _Compare>
void pop_heap(_RandomIt first, _RandomIt last, _Compare comp) {
    return eastl::pop_heap(first, last, comp);
}

template<class _RandomIt >
void sort(_RandomIt first, _RandomIt last) {
    return eastl::sort(first, last);
}

template<class _RandomIt, class _Compare>
void sort(_RandomIt first, _RandomIt last, _Compare comp) {
    return eastl::sort(first, last, comp);
}

template<class _ForwardIt, class _Tp>
std::pair<_ForwardIt, _ForwardIt>
equal_range(_ForwardIt first, _ForwardIt last, const _Tp& value) {
    return eastl::equal_range(first, last, value);
}

template<class _ForwardIt, class _Tp, class _Compare>
std::pair<_ForwardIt, _ForwardIt>
equal_range(_ForwardIt first, _ForwardIt last, const _Tp& value, _Compare comp) {
    return eastl::equal_range(first, last, value, comp);
}

template<class _InputIt, class _Tp>
_InputIt find(_InputIt first, _InputIt last, const _Tp& value) {
    return eastl::find(first, last, value);
}

template<class _InputIt, class _Up>
_InputIt find_if(_InputIt first, _InputIt last, _Up pred) {
    return eastl::find_if(first, last, pred);
}

template<class _InputIt, class _Up>
_InputIt find_if_not(_InputIt first, _InputIt last, _Up pred) {
    return eastl::find_if_not(first, last, pred);
}


} // namespace std

#endif // _EZCXX_ALGORITHM
