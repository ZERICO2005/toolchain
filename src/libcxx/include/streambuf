// -*- C++ -*-
#ifndef _EZCXX_STREAMBUF
#define _EZCXX_STREAMBUF

#pragma clang system_header

#include <ios>
#include <type_traits>
#include <climits>

namespace std {

	template <class _CharT, class _Traits>
	class _EZCXX_TEMPLATE_VIS basic_streambuf {
	public:
	  // types:
	  typedef _CharT char_type;
	  typedef _Traits traits_type;
	  typedef typename traits_type::int_type int_type;
	  typedef typename traits_type::pos_type pos_type;
	  typedef typename traits_type::off_type off_type;
	
	  static_assert(is_same<_CharT, typename traits_type::char_type>::value,
					"traits_type::char_type must be the same type as CharT");
	
	  virtual ~basic_streambuf() {}
	
	  // 27.6.2.2.2 buffer and positioning:
	  inline _EZCXX_HIDE_FROM_ABI basic_streambuf* pubsetbuf(char_type* __s, streamsize __n) {
		return setbuf(__s, __n);
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI pos_type
	  pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out) {
		return seekoff(__off, __way, __which);
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI pos_type
	  pubseekpos(pos_type __sp, ios_base::openmode __which = ios_base::in | ios_base::out) {
		return seekpos(__sp, __which);
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI int pubsync() { return sync(); }
	
	  // Get and put areas:
	  // 27.6.2.2.3 Get area:
	  inline _EZCXX_HIDE_FROM_ABI streamsize in_avail() {
		if (__ninp_ < __einp_)
		  return static_cast<streamsize>(__einp_ - __ninp_);
		return showmanyc();
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI int_type snextc() {
		if (sbumpc() == traits_type::eof())
		  return traits_type::eof();
		return sgetc();
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI int_type sbumpc() {
		if (__ninp_ == __einp_)
		  return uflow();
		return traits_type::to_int_type(*__ninp_++);
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI int_type sgetc() {
		if (__ninp_ == __einp_)
		  return underflow();
		return traits_type::to_int_type(*__ninp_);
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI streamsize sgetn(char_type* __s, streamsize __n) { return xsgetn(__s, __n); }
	
	  // 27.6.2.2.4 Putback:
	  inline _EZCXX_HIDE_FROM_ABI int_type sputbackc(char_type __c) {
		if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
		  return pbackfail(traits_type::to_int_type(__c));
		return traits_type::to_int_type(*--__ninp_);
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI int_type sungetc() {
		if (__binp_ == __ninp_)
		  return pbackfail();
		return traits_type::to_int_type(*--__ninp_);
	  }
	
	  // 27.6.2.2.5 Put area:
	  inline _EZCXX_HIDE_FROM_ABI int_type sputc(char_type __c) {
		if (__nout_ == __eout_)
		  return overflow(traits_type::to_int_type(__c));
		*__nout_++ = __c;
		return traits_type::to_int_type(__c);
	  }
	
	  inline _EZCXX_HIDE_FROM_ABI streamsize sputn(const char_type* __s, streamsize __n) {
		return xsputn(__s, __n);
	  }
	
	protected:
	  basic_streambuf() {}
	  basic_streambuf(const basic_streambuf& __sb)
		  :
			__binp_(__sb.__binp_),
			__ninp_(__sb.__ninp_),
			__einp_(__sb.__einp_),
			__bout_(__sb.__bout_),
			__nout_(__sb.__nout_),
			__eout_(__sb.__eout_) {}
	
	  basic_streambuf& operator=(const basic_streambuf& __sb) {
		__binp_ = __sb.__binp_;
		__ninp_ = __sb.__ninp_;
		__einp_ = __sb.__einp_;
		__bout_ = __sb.__bout_;
		__nout_ = __sb.__nout_;
		__eout_ = __sb.__eout_;
		return *this;
	  }
	
	  void swap(basic_streambuf& __sb) {
		std::swap(__binp_, __sb.__binp_);
		std::swap(__ninp_, __sb.__ninp_);
		std::swap(__einp_, __sb.__einp_);
		std::swap(__bout_, __sb.__bout_);
		std::swap(__nout_, __sb.__nout_);
		std::swap(__eout_, __sb.__eout_);
	  }
	
	  // 27.6.2.3.2 Get area:
	  _EZCXX_HIDE_FROM_ABI char_type* eback() const { return __binp_; }
	  _EZCXX_HIDE_FROM_ABI char_type* gptr() const { return __ninp_; }
	  _EZCXX_HIDE_FROM_ABI char_type* egptr() const { return __einp_; }
	
	  inline _EZCXX_HIDE_FROM_ABI void gbump(int __n) { __ninp_ += __n; }
	
	  inline _EZCXX_HIDE_FROM_ABI void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
		#if 0
		_EZCXX_ASSERT_VALID_INPUT_RANGE(std::__is_valid_range(__gbeg, __gnext), "[gbeg, gnext) must be a valid range");
		_EZCXX_ASSERT_VALID_INPUT_RANGE(std::__is_valid_range(__gbeg, __gend), "[gbeg, gend) must be a valid range");
		_EZCXX_ASSERT_VALID_INPUT_RANGE(std::__is_valid_range(__gnext, __gend), "[gnext, gend) must be a valid range");
		#endif
		__binp_ = __gbeg;
		__ninp_ = __gnext;
		__einp_ = __gend;
	  }
	
	  // 27.6.2.3.3 Put area:
	  _EZCXX_HIDE_FROM_ABI char_type* pbase() const { return __bout_; }
	  _EZCXX_HIDE_FROM_ABI char_type* pptr() const { return __nout_; }
	  _EZCXX_HIDE_FROM_ABI char_type* epptr() const { return __eout_; }
	
	  inline _EZCXX_HIDE_FROM_ABI void pbump(int __n) { __nout_ += __n; }
	
	  _EZCXX_HIDE_FROM_ABI void __pbump(streamsize __n) { __nout_ += __n; }
	
	  inline _EZCXX_HIDE_FROM_ABI void setp(char_type* __pbeg, char_type* __pend) {
		#if 0
		_EZCXX_ASSERT_VALID_INPUT_RANGE(std::__is_valid_range(__pbeg, __pend), "[pbeg, pend) must be a valid range");
		#endif
		__bout_ = __nout_ = __pbeg;
		__eout_           = __pend;
	  }
	
	  // 27.6.2.4 virtual functions:
	
	  // 27.6.2.4.2 Buffer management and positioning:
	  virtual basic_streambuf* setbuf(char_type*, streamsize) { return this; }
	  virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {
		return pos_type(off_type(-1));
	  }
	  virtual pos_type seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {
		return pos_type(off_type(-1));
	  }
	  virtual int sync() { return 0; }
	
	  // 27.6.2.4.3 Get area:
	  virtual streamsize showmanyc() { return 0; }
	
	  virtual streamsize xsgetn(char_type* __s, streamsize __n) {
		const int_type __eof = traits_type::eof();
		int_type __c;
		streamsize __i = 0;
		while (__i < __n) {
		  if (__ninp_ < __einp_) {
			const streamsize __len = std::min(static_cast<streamsize>(INT_MAX), std::min(__einp_ - __ninp_, __n - __i));
			traits_type::copy(__s, __ninp_, __len);
			__s += __len;
			__i += __len;
			this->gbump(__len);
		  } else if ((__c = uflow()) != __eof) {
			*__s = traits_type::to_char_type(__c);
			++__s;
			++__i;
		  } else
			break;
		}
		return __i;
	  }
	
	  virtual int_type underflow() { return traits_type::eof(); }
	  virtual int_type uflow() {
		if (underflow() == traits_type::eof())
		  return traits_type::eof();
		return traits_type::to_int_type(*__ninp_++);
	  }
	
	  // 27.6.2.4.4 Putback:
	  virtual int_type pbackfail(int_type = traits_type::eof()) { return traits_type::eof(); }
	
	  // 27.6.2.4.5 Put area:
	  virtual streamsize xsputn(const char_type* __s, streamsize __n) {
		streamsize __i = 0;
		int_type __eof = traits_type::eof();
		while (__i < __n) {
		  if (__nout_ >= __eout_) {
			if (overflow(traits_type::to_int_type(*__s)) == __eof)
			  break;
			++__s;
			++__i;
		  } else {
			streamsize __chunk_size = std::min(__eout_ - __nout_, __n - __i);
			traits_type::copy(__nout_, __s, __chunk_size);
			__nout_ += __chunk_size;
			__s += __chunk_size;
			__i += __chunk_size;
		  }
		}
		return __i;
	  }
	
	  virtual int_type overflow(int_type = traits_type::eof()) { return traits_type::eof(); }
	
	private:
	  char_type* __binp_ = nullptr;
	  char_type* __ninp_ = nullptr;
	  char_type* __einp_ = nullptr;
	  char_type* __bout_ = nullptr;
	  char_type* __nout_ = nullptr;
	  char_type* __eout_ = nullptr;
	};
	
	extern template class _EZCXX_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>;

} // namespace std

#endif // _EZCXX_STREAMBUF
